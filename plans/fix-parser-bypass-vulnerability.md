# Fix Parser Bypass Vulnerability

## Problem Statement

The command parser in `src/parser.ts` has a **MEDIUM severity** security bypass vulnerability. The regex patterns use the `^` anchor which only matches commands at the start of the string:

```typescript
const npmRegex = /^(npm|npx)\s+(install|i|add)\s+/;
const pipRegex = /^pip(3)?\s+install\s+/;
const brewRegex = /^brew\s+install\s+/;
```

This allows attackers to bypass vulnerability checking with compound commands:
- `cd /tmp && npm install malicious-package`
- `NODE_ENV=prod npm install vulnerable-lib`
- `bash -c "npm install backdoor"`
- `true; pip install evil`

## Solution Overview

Replace naive regex matching with proper shell command parsing using the `shell-quote` library. This will:
1. Split compound commands on operators (`&&`, `||`, `;`, `|`)
2. Handle environment variable prefixes
3. Detect nested shell invocations (`bash -c`, `sh -c`)
4. Extract all install commands regardless of position

## Implementation Steps

### Step 1: Add shell-quote dependency

```bash
npm install shell-quote
npm install -D @types/shell-quote
```

### Step 2: Refactor parser.ts

Replace the current implementation with shell-aware parsing:

```typescript
import { parse } from 'shell-quote';

export interface ParsedPackage {
  name: string;
  version?: string;
  ecosystem: 'npm' | 'pypi' | 'homebrew';
}

type ParsedToken = string | { op: string } | { comment: string } | { pattern: string };

function isOperator(token: ParsedToken): token is { op: string } {
  return typeof token === 'object' && 'op' in token;
}

function extractCommands(input: string): string[][] {
  const tokens = parse(input);
  const commands: string[][] = [];
  let current: string[] = [];

  for (const token of tokens) {
    if (isOperator(token)) {
      if (['&&', '||', ';', '|'].includes(token.op) && current.length > 0) {
        commands.push(current);
        current = [];
      }
    } else if (typeof token === 'string') {
      // Skip environment variable assignments (KEY=value before command)
      if (current.length === 0 && token.includes('=') && !token.startsWith('-')) {
        continue;
      }
      current.push(token);
    }
  }

  if (current.length > 0) {
    commands.push(current);
  }

  return commands;
}

function parseNestedCommand(args: string[]): string[][] {
  // Handle: bash -c "npm install pkg", sh -c "pip install pkg"
  const shellBinaries = ['bash', 'sh', 'zsh', '/bin/bash', '/bin/sh', '/bin/zsh'];
  if (args.length >= 3 && shellBinaries.includes(args[0]) && args[1] === '-c') {
    return extractCommands(args.slice(2).join(' '));
  }
  return [args];
}

function parsePackagesFromArgs(args: string[], ecosystem: ParsedPackage['ecosystem']): ParsedPackage[] {
  const packages: ParsedPackage[] = [];

  for (const arg of args) {
    if (arg.startsWith('-')) continue; // Skip flags

    if (ecosystem === 'npm' || ecosystem === 'homebrew') {
      const lastAt = arg.lastIndexOf('@');
      if (lastAt > 0) {
        packages.push({ name: arg.substring(0, lastAt), version: arg.substring(lastAt + 1), ecosystem });
      } else {
        packages.push({ name: arg, ecosystem });
      }
    } else if (ecosystem === 'pypi') {
      const idx = arg.indexOf('==');
      if (idx > 0) {
        packages.push({ name: arg.substring(0, idx), version: arg.substring(idx + 2), ecosystem });
      } else {
        packages.push({ name: arg, ecosystem });
      }
    }
  }

  return packages;
}

function detectInstallCommand(args: string[]): { ecosystem: ParsedPackage['ecosystem']; packageArgs: string[] } | null {
  if (args.length < 2) return null;

  const cmd = args[0];
  const subcmd = args[1];

  // npm install, npm i, npm add, npx install
  if ((cmd === 'npm' || cmd === 'npx') && ['install', 'i', 'add'].includes(subcmd)) {
    return { ecosystem: 'npm', packageArgs: args.slice(2) };
  }

  // pip install, pip3 install
  if ((cmd === 'pip' || cmd === 'pip3') && subcmd === 'install') {
    return { ecosystem: 'pypi', packageArgs: args.slice(2) };
  }

  // brew install
  if (cmd === 'brew' && subcmd === 'install') {
    return { ecosystem: 'homebrew', packageArgs: args.slice(2) };
  }

  return null;
}

export function parseInstallCommand(command: string): ParsedPackage[] | null {
  const allPackages: ParsedPackage[] = [];

  // Extract all commands from the input (handles &&, ||, ;, |)
  const commands = extractCommands(command);

  for (const args of commands) {
    // Check for nested shell commands
    const nestedCommands = parseNestedCommand(args);

    for (const nested of nestedCommands) {
      const install = detectInstallCommand(nested);
      if (install) {
        const packages = parsePackagesFromArgs(install.packageArgs, install.ecosystem);
        allPackages.push(...packages);
      }
    }
  }

  return allPackages.length > 0 ? allPackages : null;
}
```

### Step 3: Add comprehensive tests

Create `src/parser.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { parseInstallCommand } from './parser.js';

describe('parseInstallCommand', () => {
  describe('basic commands', () => {
    it('parses npm install', () => {
      expect(parseInstallCommand('npm install lodash')).toEqual([
        { name: 'lodash', ecosystem: 'npm' }
      ]);
    });

    it('parses npm i (shorthand)', () => {
      expect(parseInstallCommand('npm i express')).toEqual([
        { name: 'express', ecosystem: 'npm' }
      ]);
    });

    it('parses pip install', () => {
      expect(parseInstallCommand('pip install requests')).toEqual([
        { name: 'requests', ecosystem: 'pypi' }
      ]);
    });

    it('parses brew install', () => {
      expect(parseInstallCommand('brew install wget')).toEqual([
        { name: 'wget', ecosystem: 'homebrew' }
      ]);
    });
  });

  describe('versioned packages', () => {
    it('parses npm package@version', () => {
      expect(parseInstallCommand('npm install lodash@4.17.21')).toEqual([
        { name: 'lodash', version: '4.17.21', ecosystem: 'npm' }
      ]);
    });

    it('parses pip package==version', () => {
      expect(parseInstallCommand('pip install requests==2.28.0')).toEqual([
        { name: 'requests', version: '2.28.0', ecosystem: 'pypi' }
      ]);
    });

    it('parses scoped npm packages', () => {
      expect(parseInstallCommand('npm install @types/node@20.0.0')).toEqual([
        { name: '@types/node', version: '20.0.0', ecosystem: 'npm' }
      ]);
    });
  });

  describe('command chaining bypass prevention', () => {
    it('catches npm install after cd', () => {
      expect(parseInstallCommand('cd /tmp && npm install malicious')).toEqual([
        { name: 'malicious', ecosystem: 'npm' }
      ]);
    });

    it('catches pip install after semicolon', () => {
      expect(parseInstallCommand('true; pip install evil')).toEqual([
        { name: 'evil', ecosystem: 'pypi' }
      ]);
    });

    it('catches install after OR operator', () => {
      expect(parseInstallCommand('false || npm install backdoor')).toEqual([
        { name: 'backdoor', ecosystem: 'npm' }
      ]);
    });

    it('catches install in pipe chain', () => {
      expect(parseInstallCommand('echo test | npm install compromised')).toEqual([
        { name: 'compromised', ecosystem: 'npm' }
      ]);
    });
  });

  describe('environment variable prefixes', () => {
    it('handles NODE_ENV prefix', () => {
      expect(parseInstallCommand('NODE_ENV=production npm install pkg')).toEqual([
        { name: 'pkg', ecosystem: 'npm' }
      ]);
    });

    it('handles multiple env vars', () => {
      expect(parseInstallCommand('CI=true DEBUG=1 npm install lib')).toEqual([
        { name: 'lib', ecosystem: 'npm' }
      ]);
    });
  });

  describe('nested shell commands', () => {
    it('catches bash -c nested install', () => {
      expect(parseInstallCommand('bash -c "npm install hidden"')).toEqual([
        { name: 'hidden', ecosystem: 'npm' }
      ]);
    });

    it('catches sh -c nested install', () => {
      expect(parseInstallCommand('sh -c "pip install sneaky"')).toEqual([
        { name: 'sneaky', ecosystem: 'pypi' }
      ]);
    });
  });

  describe('multiple packages', () => {
    it('parses multiple npm packages', () => {
      expect(parseInstallCommand('npm install lodash express axios')).toEqual([
        { name: 'lodash', ecosystem: 'npm' },
        { name: 'express', ecosystem: 'npm' },
        { name: 'axios', ecosystem: 'npm' }
      ]);
    });

    it('parses multiple installs in chain', () => {
      expect(parseInstallCommand('npm install pkg1 && pip install pkg2')).toEqual([
        { name: 'pkg1', ecosystem: 'npm' },
        { name: 'pkg2', ecosystem: 'pypi' }
      ]);
    });
  });

  describe('non-install commands', () => {
    it('returns null for non-install commands', () => {
      expect(parseInstallCommand('npm test')).toBeNull();
      expect(parseInstallCommand('git clone repo')).toBeNull();
      expect(parseInstallCommand('ls -la')).toBeNull();
    });

    it('returns null for empty input', () => {
      expect(parseInstallCommand('')).toBeNull();
    });
  });

  describe('flags are ignored', () => {
    it('ignores -D flag', () => {
      expect(parseInstallCommand('npm install -D typescript')).toEqual([
        { name: 'typescript', ecosystem: 'npm' }
      ]);
    });

    it('ignores --save-dev flag', () => {
      expect(parseInstallCommand('npm install --save-dev jest')).toEqual([
        { name: 'jest', ecosystem: 'npm' }
      ]);
    });
  });
});
```

### Step 4: Run tests and verify

```bash
npm test
```

### Step 5: Manual verification

Test with real bypass attempts:

```bash
echo '{"hook_event_name":"PreToolUse","tool_name":"Bash","tool_input":{"command":"cd /tmp && npm install lodash@4.17.0"}}' | npx tsx src/index.ts
# Should output: deny (lodash 4.17.0 has vulnerabilities)

echo '{"hook_event_name":"PreToolUse","tool_name":"Bash","tool_input":{"command":"bash -c \"npm install lodash@4.17.0\""}}' | npx tsx src/index.ts
# Should output: deny
```

## Risk Assessment

- **Breaking changes**: None - the function signature remains the same
- **Performance**: Minimal impact - shell-quote is lightweight
- **Fail behavior**: If parsing fails, we fail-open (allow) to avoid blocking legitimate commands

## Acceptance Criteria

1. All bypass vectors are blocked:
   - `cd /tmp && npm install malicious` - DETECTED
   - `NODE_ENV=prod npm install vulnerable` - DETECTED
   - `bash -c "npm install hidden"` - DETECTED
   - `true; pip install evil` - DETECTED

2. Existing functionality preserved:
   - `npm install lodash` - still works
   - `npm install lodash@4.17.21` - version parsed correctly
   - `pip install requests==2.28.0` - version parsed correctly

3. All tests pass with 100% coverage of parser.ts
